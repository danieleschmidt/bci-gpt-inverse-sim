"""Compliance Monitor for BCI-GPT Self-Healing System.

Ensures regulatory compliance (GDPR, HIPAA, FDA) and maintains
audit trails for medical device and data protection requirements.
"""

import asyncio
import logging
import threading
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Callable, Set
from dataclasses import dataclass, field
from collections import deque
from enum import Enum
import json
import hashlib

from ..utils.monitoring import HealthStatus
from ..utils.error_handling import BCI_GPTError
from ..compliance.gdpr import GDPRCompliance
from ..compliance.data_protection import DataProtectionManager


class ComplianceFramework(Enum):
    """Supported compliance frameworks."""
    GDPR = "gdpr"
    HIPAA = "hipaa"
    FDA = "fda"
    ISO_27001 = "iso_27001"
    SOC_2 = "soc_2"
    NIST = "nist"


class ComplianceStatus(Enum):
    """Compliance status levels."""
    COMPLIANT = "compliant"
    WARNING = "warning"
    VIOLATION = "violation"
    UNKNOWN = "unknown"


class DataClassification(Enum):
    """Data classification levels."""
    PUBLIC = "public"
    INTERNAL = "internal"
    CONFIDENTIAL = "confidential"
    RESTRICTED = "restricted"
    TOP_SECRET = "top_secret"


@dataclass
class ComplianceViolation:
    """Compliance violation record."""
    framework: ComplianceFramework
    rule_id: str
    severity: str
    description: str
    component: str
    data_involved: List[str]
    timestamp: datetime = field(default_factory=datetime.now)
    resolved: bool = False
    remediation_actions: List[str] = field(default_factory=list)
    evidence: Dict[str, Any] = field(default_factory=dict)


@dataclass
class DataProcessingRecord:
    """Record of data processing for audit trail."""
    data_type: str
    classification: DataClassification
    purpose: str
    legal_basis: str
    data_subject_id: Optional[str]
    processing_activity: str
    retention_period: int  # days
    processor_id: str
    timestamp: datetime = field(default_factory=datetime.now)
    consent_id: Optional[str] = None
    anonymized: bool = False


@dataclass
class ComplianceRule:
    """Compliance rule definition."""
    rule_id: str
    framework: ComplianceFramework
    title: str
    description: str
    severity: str
    check_function: str
    parameters: Dict[str, Any] = field(default_factory=dict)
    enabled: bool = True


class ComplianceMonitor:
    """Comprehensive compliance monitoring for BCI-GPT system.
    
    Monitors compliance with medical device regulations, data protection laws,
    and security standards with automated violation detection and remediation.
    """
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
        # Monitoring state
        self.monitoring_active = False
        self.monitoring_thread: Optional[threading.Thread] = None
        
        # Compliance frameworks
        self.enabled_frameworks: Set[ComplianceFramework] = {
            ComplianceFramework.GDPR,
            ComplianceFramework.HIPAA,
            ComplianceFramework.FDA
        }
        
        # Violation tracking
        self.violations: deque = deque(maxlen=1000)
        self.compliance_status: Dict[ComplianceFramework, ComplianceStatus] = {}
        
        # Data processing tracking\n        self.data_processing_records: deque = deque(maxlen=10000)\n        self.data_retention_schedule: Dict[str, Dict[str, Any]] = {}\n        self.consent_records: Dict[str, Dict[str, Any]] = {}\n        \n        # Compliance rules\n        self.compliance_rules: Dict[str, ComplianceRule] = {}\n        \n        # Audit trail\n        self.audit_trail: deque = deque(maxlen=50000)\n        \n        # Callbacks\n        self.violation_callbacks: List[Callable] = []\n        self.audit_callbacks: List[Callable] = []\n        \n        # Compliance managers\n        self.gdpr_manager = GDPRCompliance()\n        self.data_protection_manager = DataProtectionManager()\n        \n        # Statistics\n        self.total_checks = 0\n        self.total_violations = 0\n        self.resolved_violations = 0\n        self.monitor_start_time = datetime.now()\n        \n        # Initialize compliance rules\n        self._initialize_compliance_rules()\n    \n    def _initialize_compliance_rules(self) -> None:\n        \"\"\"Initialize compliance rules for different frameworks.\"\"\"\n        # GDPR Rules\n        gdpr_rules = [\n            ComplianceRule(\n                rule_id=\"GDPR-01\",\n                framework=ComplianceFramework.GDPR,\n                title=\"Data Minimization\",\n                description=\"Ensure only necessary personal data is processed\",\n                severity=\"high\",\n                check_function=\"check_data_minimization\"\n            ),\n            ComplianceRule(\n                rule_id=\"GDPR-02\",\n                framework=ComplianceFramework.GDPR,\n                title=\"Consent Management\",\n                description=\"Verify valid consent exists for data processing\",\n                severity=\"critical\",\n                check_function=\"check_consent_validity\"\n            ),\n            ComplianceRule(\n                rule_id=\"GDPR-03\",\n                framework=ComplianceFramework.GDPR,\n                title=\"Data Retention\",\n                description=\"Ensure data is not retained longer than necessary\",\n                severity=\"medium\",\n                check_function=\"check_data_retention\"\n            ),\n            ComplianceRule(\n                rule_id=\"GDPR-04\",\n                framework=ComplianceFramework.GDPR,\n                title=\"Right to be Forgotten\",\n                description=\"Verify data deletion requests are properly handled\",\n                severity=\"high\",\n                check_function=\"check_deletion_requests\"\n            )\n        ]\n        \n        # HIPAA Rules\n        hipaa_rules = [\n            ComplianceRule(\n                rule_id=\"HIPAA-01\",\n                framework=ComplianceFramework.HIPAA,\n                title=\"PHI Encryption\",\n                description=\"Ensure PHI is encrypted at rest and in transit\",\n                severity=\"critical\",\n                check_function=\"check_phi_encryption\"\n            ),\n            ComplianceRule(\n                rule_id=\"HIPAA-02\",\n                framework=ComplianceFramework.HIPAA,\n                title=\"Access Controls\",\n                description=\"Verify proper access controls for PHI\",\n                severity=\"high\",\n                check_function=\"check_phi_access_controls\"\n            ),\n            ComplianceRule(\n                rule_id=\"HIPAA-03\",\n                framework=ComplianceFramework.HIPAA,\n                title=\"Audit Logging\",\n                description=\"Ensure all PHI access is logged\",\n                severity=\"medium\",\n                check_function=\"check_phi_audit_logging\"\n            )\n        ]\n        \n        # FDA Rules\n        fda_rules = [\n            ComplianceRule(\n                rule_id=\"FDA-01\",\n                framework=ComplianceFramework.FDA,\n                title=\"Software Validation\",\n                description=\"Ensure software changes are validated\",\n                severity=\"critical\",\n                check_function=\"check_software_validation\"\n            ),\n            ComplianceRule(\n                rule_id=\"FDA-02\",\n                framework=ComplianceFramework.FDA,\n                title=\"Risk Management\",\n                description=\"Verify risk management processes\",\n                severity=\"high\",\n                check_function=\"check_risk_management\"\n            ),\n            ComplianceRule(\n                rule_id=\"FDA-03\",\n                framework=ComplianceFramework.FDA,\n                title=\"Adverse Event Reporting\",\n                description=\"Ensure adverse events are properly reported\",\n                severity=\"critical\",\n                check_function=\"check_adverse_event_reporting\"\n            )\n        ]\n        \n        # Register all rules\n        all_rules = gdpr_rules + hipaa_rules + fda_rules\n        for rule in all_rules:\n            self.compliance_rules[rule.rule_id] = rule\n    \n    def start_monitoring(self) -> None:\n        \"\"\"Start compliance monitoring.\"\"\"\n        if self.monitoring_active:\n            return\n        \n        self.monitoring_active = True\n        self.monitoring_thread = threading.Thread(target=self._monitoring_loop, daemon=True)\n        self.monitoring_thread.start()\n        \n        self.logger.info(\"Compliance monitoring started\")\n    \n    def stop_monitoring(self) -> None:\n        \"\"\"Stop compliance monitoring.\"\"\"\n        self.monitoring_active = False\n        \n        if self.monitoring_thread:\n            self.monitoring_thread.join(timeout=10.0)\n        \n        self.logger.info(\"Compliance monitoring stopped\")\n    \n    def _monitoring_loop(self) -> None:\n        \"\"\"Main compliance monitoring loop.\"\"\"\n        while self.monitoring_active:\n            try:\n                # Run compliance checks\n                self._run_compliance_checks()\n                \n                # Check data retention schedules\n                self._check_data_retention_schedules()\n                \n                # Validate consent records\n                self._validate_consent_records()\n                \n                # Monitor data processing activities\n                self._monitor_data_processing()\n                \n                # Update compliance status\n                self._update_compliance_status()\n                \n                # Clean up old records\n                self._cleanup_old_records()\n                \n            except Exception as e:\n                self.logger.error(f\"Compliance monitoring error: {e}\")\n            \n            threading.Event().wait(300)  # Check every 5 minutes\n    \n    def _run_compliance_checks(self) -> None:\n        \"\"\"Run all enabled compliance checks.\"\"\"\n        for rule_id, rule in self.compliance_rules.items():\n            if not rule.enabled:\n                continue\n            \n            if rule.framework not in self.enabled_frameworks:\n                continue\n            \n            try:\n                self.total_checks += 1\n                violation = self._execute_compliance_check(rule)\n                \n                if violation:\n                    self._record_violation(violation)\n                    \n            except Exception as e:\n                self.logger.error(f\"Compliance check {rule_id} failed: {e}\")\n    \n    def _execute_compliance_check(self, rule: ComplianceRule) -> Optional[ComplianceViolation]:\n        \"\"\"Execute a specific compliance check.\"\"\"\n        check_function = getattr(self, rule.check_function, None)\n        if not check_function:\n            self.logger.warning(f\"Check function {rule.check_function} not found\")\n            return None\n        \n        try:\n            result = check_function(rule.parameters)\n            \n            if result and result.get(\"violation\"):\n                return ComplianceViolation(\n                    framework=rule.framework,\n                    rule_id=rule.rule_id,\n                    severity=rule.severity,\n                    description=result[\"description\"],\n                    component=result.get(\"component\", \"unknown\"),\n                    data_involved=result.get(\"data_involved\", []),\n                    evidence=result.get(\"evidence\", {})\n                )\n            \n            return None\n            \n        except Exception as e:\n            self.logger.error(f\"Compliance check execution failed: {e}\")\n            return None\n    \n    # GDPR Compliance Checks\n    \n    def check_data_minimization(self, parameters: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Check GDPR data minimization principle.\"\"\"\n        # Check if we're processing more data than necessary\n        # This would analyze data processing records\n        \n        excessive_data_processing = self._analyze_data_processing_necessity()\n        \n        if excessive_data_processing:\n            return {\n                \"violation\": True,\n                \"description\": \"Processing more personal data than necessary for stated purpose\",\n                \"component\": \"data_processing\",\n                \"data_involved\": excessive_data_processing,\n                \"evidence\": {\"excessive_fields\": excessive_data_processing}\n            }\n        \n        return {\"violation\": False}\n    \n    def check_consent_validity(self, parameters: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Check GDPR consent validity.\"\"\"\n        invalid_consents = []\n        \n        for consent_id, consent_data in self.consent_records.items():\n            if not self._is_consent_valid(consent_data):\n                invalid_consents.append(consent_id)\n        \n        if invalid_consents:\n            return {\n                \"violation\": True,\n                \"description\": f\"Invalid or expired consent records found\",\n                \"component\": \"consent_management\",\n                \"data_involved\": invalid_consents,\n                \"evidence\": {\"invalid_consents\": invalid_consents}\n            }\n        \n        return {\"violation\": False}\n    \n    def check_data_retention(self, parameters: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Check GDPR data retention compliance.\"\"\"\n        overdue_data = []\n        current_time = datetime.now()\n        \n        for record in self.data_processing_records:\n            retention_end = record.timestamp + timedelta(days=record.retention_period)\n            if current_time > retention_end and not record.anonymized:\n                overdue_data.append({\n                    \"data_type\": record.data_type,\n                    \"subject_id\": record.data_subject_id,\n                    \"overdue_days\": (current_time - retention_end).days\n                })\n        \n        if overdue_data:\n            return {\n                \"violation\": True,\n                \"description\": \"Data retained longer than permitted retention period\",\n                \"component\": \"data_retention\",\n                \"data_involved\": [d[\"data_type\"] for d in overdue_data],\n                \"evidence\": {\"overdue_data\": overdue_data}\n            }\n        \n        return {\"violation\": False}\n    \n    def check_deletion_requests(self, parameters: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Check GDPR right to be forgotten compliance.\"\"\"\n        # This would check for unprocessed deletion requests\n        # Simplified implementation\n        \n        pending_deletions = self._get_pending_deletion_requests()\n        \n        if pending_deletions:\n            return {\n                \"violation\": True,\n                \"description\": \"Pending deletion requests not processed within required timeframe\",\n                \"component\": \"data_deletion\",\n                \"data_involved\": [req[\"subject_id\"] for req in pending_deletions],\n                \"evidence\": {\"pending_requests\": pending_deletions}\n            }\n        \n        return {\"violation\": False}\n    \n    # HIPAA Compliance Checks\n    \n    def check_phi_encryption(self, parameters: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Check HIPAA PHI encryption requirements.\"\"\"\n        unencrypted_phi = self._scan_for_unencrypted_phi()\n        \n        if unencrypted_phi:\n            return {\n                \"violation\": True,\n                \"description\": \"PHI found without proper encryption\",\n                \"component\": \"data_encryption\",\n                \"data_involved\": unencrypted_phi,\n                \"evidence\": {\"unencrypted_locations\": unencrypted_phi}\n            }\n        \n        return {\"violation\": False}\n    \n    def check_phi_access_controls(self, parameters: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Check HIPAA PHI access controls.\"\"\"\n        access_violations = self._check_phi_access_patterns()\n        \n        if access_violations:\n            return {\n                \"violation\": True,\n                \"description\": \"Improper PHI access patterns detected\",\n                \"component\": \"access_control\",\n                \"data_involved\": [v[\"phi_type\"] for v in access_violations],\n                \"evidence\": {\"access_violations\": access_violations}\n            }\n        \n        return {\"violation\": False}\n    \n    def check_phi_audit_logging(self, parameters: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Check HIPAA PHI audit logging.\"\"\"\n        missing_audit_logs = self._check_phi_audit_completeness()\n        \n        if missing_audit_logs:\n            return {\n                \"violation\": True,\n                \"description\": \"PHI access not properly logged\",\n                \"component\": \"audit_logging\",\n                \"data_involved\": missing_audit_logs,\n                \"evidence\": {\"missing_logs\": missing_audit_logs}\n            }\n        \n        return {\"violation\": False}\n    \n    # FDA Compliance Checks\n    \n    def check_software_validation(self, parameters: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Check FDA software validation requirements.\"\"\"\n        unvalidated_changes = self._check_software_change_validation()\n        \n        if unvalidated_changes:\n            return {\n                \"violation\": True,\n                \"description\": \"Software changes deployed without proper validation\",\n                \"component\": \"software_validation\",\n                \"data_involved\": [c[\"change_id\"] for c in unvalidated_changes],\n                \"evidence\": {\"unvalidated_changes\": unvalidated_changes}\n            }\n        \n        return {\"violation\": False}\n    \n    def check_risk_management(self, parameters: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Check FDA risk management processes.\"\"\"\n        risk_violations = self._check_risk_management_process()\n        \n        if risk_violations:\n            return {\n                \"violation\": True,\n                \"description\": \"Risk management process violations detected\",\n                \"component\": \"risk_management\",\n                \"data_involved\": [v[\"risk_id\"] for v in risk_violations],\n                \"evidence\": {\"risk_violations\": risk_violations}\n            }\n        \n        return {\"violation\": False}\n    \n    def check_adverse_event_reporting(self, parameters: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Check FDA adverse event reporting.\"\"\"\n        unreported_events = self._check_adverse_event_reporting_status()\n        \n        if unreported_events:\n            return {\n                \"violation\": True,\n                \"description\": \"Adverse events not reported within required timeframe\",\n                \"component\": \"adverse_event_reporting\",\n                \"data_involved\": [e[\"event_id\"] for e in unreported_events],\n                \"evidence\": {\"unreported_events\": unreported_events}\n            }\n        \n        return {\"violation\": False}\n    \n    # Helper methods for compliance checks\n    \n    def _analyze_data_processing_necessity(self) -> List[str]:\n        \"\"\"Analyze if data processing is necessary.\"\"\"\n        # Simplified analysis - would implement actual necessity check\n        return []\n    \n    def _is_consent_valid(self, consent_data: Dict[str, Any]) -> bool:\n        \"\"\"Check if consent is valid.\"\"\"\n        if not consent_data.get(\"timestamp\"):\n            return False\n        \n        # Check if consent is expired (2 years for GDPR)\n        consent_time = datetime.fromisoformat(consent_data[\"timestamp\"])\n        expiry_time = consent_time + timedelta(days=730)  # 2 years\n        \n        if datetime.now() > expiry_time:\n            return False\n        \n        # Check if consent is specific and informed\n        return bool(consent_data.get(\"purpose\") and consent_data.get(\"informed\"))\n    \n    def _get_pending_deletion_requests(self) -> List[Dict[str, Any]]:\n        \"\"\"Get pending deletion requests.\"\"\"\n        # Simplified - would check actual deletion request system\n        return []\n    \n    def _scan_for_unencrypted_phi(self) -> List[str]:\n        \"\"\"Scan for unencrypted PHI.\"\"\"\n        # Simplified - would implement actual PHI scanning\n        return []\n    \n    def _check_phi_access_patterns(self) -> List[Dict[str, Any]]:\n        \"\"\"Check PHI access patterns for violations.\"\"\"\n        # Simplified - would analyze actual access logs\n        return []\n    \n    def _check_phi_audit_completeness(self) -> List[str]:\n        \"\"\"Check PHI audit log completeness.\"\"\"\n        # Simplified - would check actual audit logs\n        return []\n    \n    def _check_software_change_validation(self) -> List[Dict[str, Any]]:\n        \"\"\"Check software change validation status.\"\"\"\n        # Simplified - would check actual change management system\n        return []\n    \n    def _check_risk_management_process(self) -> List[Dict[str, Any]]:\n        \"\"\"Check risk management process compliance.\"\"\"\n        # Simplified - would check actual risk management system\n        return []\n    \n    def _check_adverse_event_reporting_status(self) -> List[Dict[str, Any]]:\n        \"\"\"Check adverse event reporting status.\"\"\"\n        # Simplified - would check actual adverse event system\n        return []\n    \n    def _record_violation(self, violation: ComplianceViolation) -> None:\n        \"\"\"Record a compliance violation.\"\"\"\n        self.violations.append(violation)\n        self.total_violations += 1\n        \n        # Add to audit trail\n        self._add_audit_entry(\"compliance_violation\", {\n            \"framework\": violation.framework.value,\n            \"rule_id\": violation.rule_id,\n            \"severity\": violation.severity,\n            \"description\": violation.description,\n            \"component\": violation.component,\n            \"timestamp\": violation.timestamp.isoformat()\n        })\n        \n        # Trigger callbacks for high/critical violations\n        if violation.severity in [\"high\", \"critical\"]:\n            self._trigger_violation_callbacks(violation)\n            \n            # Auto-remediation for critical violations\n            if violation.severity == \"critical\":\n                asyncio.run(self._auto_remediate_violation(violation))\n        \n        self.logger.warning(f\"Compliance violation: {violation.framework.value} - {violation.description}\")\n    \n    async def _auto_remediate_violation(self, violation: ComplianceViolation) -> None:\n        \"\"\"Automatically remediate critical compliance violations.\"\"\"\n        self.logger.critical(f\"Auto-remediating critical violation: {violation.rule_id}\")\n        \n        remediation_actions = []\n        \n        # GDPR auto-remediation\n        if violation.framework == ComplianceFramework.GDPR:\n            if violation.rule_id == \"GDPR-03\":  # Data retention\n                # Auto-anonymize or delete overdue data\n                remediation_actions.append(\"auto_anonymize_overdue_data\")\n            elif violation.rule_id == \"GDPR-02\":  # Invalid consent\n                # Stop processing data with invalid consent\n                remediation_actions.append(\"stop_processing_invalid_consent\")\n        \n        # HIPAA auto-remediation\n        elif violation.framework == ComplianceFramework.HIPAA:\n            if violation.rule_id == \"HIPAA-01\":  # PHI encryption\n                # Encrypt unencrypted PHI\n                remediation_actions.append(\"encrypt_unencrypted_phi\")\n            elif violation.rule_id == \"HIPAA-02\":  # Access controls\n                # Revoke improper access\n                remediation_actions.append(\"revoke_improper_access\")\n        \n        # FDA auto-remediation\n        elif violation.framework == ComplianceFramework.FDA:\n            if violation.rule_id == \"FDA-01\":  # Software validation\n                # Rollback unvalidated changes\n                remediation_actions.append(\"rollback_unvalidated_changes\")\n        \n        # Update violation with remediation actions\n        violation.remediation_actions = remediation_actions\n        \n        # Execute remediation actions\n        for action in remediation_actions:\n            try:\n                await self._execute_remediation_action(action, violation)\n            except Exception as e:\n                self.logger.error(f\"Remediation action {action} failed: {e}\")\n    \n    async def _execute_remediation_action(self, action: str, violation: ComplianceViolation) -> None:\n        \"\"\"Execute a specific remediation action.\"\"\"\n        self.logger.info(f\"Executing remediation action: {action}\")\n        \n        # Simulate remediation actions\n        await asyncio.sleep(0.1)\n        \n        # Add to audit trail\n        self._add_audit_entry(\"remediation_action\", {\n            \"action\": action,\n            \"violation_id\": violation.rule_id,\n            \"component\": violation.component,\n            \"timestamp\": datetime.now().isoformat()\n        })\n    \n    def _check_data_retention_schedules(self) -> None:\n        \"\"\"Check data retention schedules.\"\"\"\n        current_time = datetime.now()\n        \n        for data_type, schedule in self.data_retention_schedule.items():\n            if schedule[\"next_review\"] <= current_time:\n                self._review_data_retention(data_type)\n                # Update next review date\n                schedule[\"next_review\"] = current_time + timedelta(days=30)\n    \n    def _review_data_retention(self, data_type: str) -> None:\n        \"\"\"Review data retention for specific data type.\"\"\"\n        # This would implement actual data retention review\n        self._add_audit_entry(\"data_retention_review\", {\n            \"data_type\": data_type,\n            \"timestamp\": datetime.now().isoformat()\n        })\n    \n    def _validate_consent_records(self) -> None:\n        \"\"\"Validate all consent records.\"\"\"\n        expired_consents = []\n        \n        for consent_id, consent_data in self.consent_records.items():\n            if not self._is_consent_valid(consent_data):\n                expired_consents.append(consent_id)\n        \n        if expired_consents:\n            self.logger.warning(f\"Found {len(expired_consents)} expired consent records\")\n    \n    def _monitor_data_processing(self) -> None:\n        \"\"\"Monitor ongoing data processing activities.\"\"\"\n        # This would monitor real-time data processing\n        # and ensure compliance with stated purposes\n        pass\n    \n    def _update_compliance_status(self) -> None:\n        \"\"\"Update overall compliance status for each framework.\"\"\"\n        for framework in self.enabled_frameworks:\n            recent_violations = [\n                v for v in self.violations\n                if v.framework == framework and (datetime.now() - v.timestamp).days < 30\n            ]\n            \n            critical_violations = [v for v in recent_violations if v.severity == \"critical\"]\n            high_violations = [v for v in recent_violations if v.severity == \"high\"]\n            \n            if critical_violations:\n                self.compliance_status[framework] = ComplianceStatus.VIOLATION\n            elif high_violations:\n                self.compliance_status[framework] = ComplianceStatus.WARNING\n            else:\n                self.compliance_status[framework] = ComplianceStatus.COMPLIANT\n    \n    def _cleanup_old_records(self) -> None:\n        \"\"\"Clean up old compliance records.\"\"\"\n        cutoff_time = datetime.now() - timedelta(days=365)  # Keep 1 year of records\n        \n        # Clean up old data processing records\n        self.data_processing_records = deque(\n            [r for r in self.data_processing_records if r.timestamp > cutoff_time],\n            maxlen=self.data_processing_records.maxlen\n        )\n    \n    def _trigger_violation_callbacks(self, violation: ComplianceViolation) -> None:\n        \"\"\"Trigger violation callbacks.\"\"\"\n        for callback in self.violation_callbacks:\n            try:\n                callback(violation)\n            except Exception as e:\n                self.logger.error(f\"Violation callback error: {e}\")\n    \n    def _add_audit_entry(self, event_type: str, details: Dict[str, Any]) -> None:\n        \"\"\"Add entry to audit trail.\"\"\"\n        audit_entry = {\n            \"timestamp\": datetime.now(),\n            \"event_type\": event_type,\n            \"details\": details\n        }\n        \n        self.audit_trail.append(audit_entry)\n        \n        # Trigger audit callbacks\n        for callback in self.audit_callbacks:\n            try:\n                callback(audit_entry)\n            except Exception as e:\n                self.logger.error(f\"Audit callback error: {e}\")\n    \n    def record_data_processing(self, data_type: str, classification: DataClassification,\n                              purpose: str, legal_basis: str, data_subject_id: Optional[str],\n                              processing_activity: str, retention_period: int,\n                              processor_id: str, consent_id: Optional[str] = None) -> None:\n        \"\"\"Record data processing activity.\"\"\"\n        record = DataProcessingRecord(\n            data_type=data_type,\n            classification=classification,\n            purpose=purpose,\n            legal_basis=legal_basis,\n            data_subject_id=data_subject_id,\n            processing_activity=processing_activity,\n            retention_period=retention_period,\n            processor_id=processor_id,\n            consent_id=consent_id\n        )\n        \n        self.data_processing_records.append(record)\n        \n        # Add to audit trail\n        self._add_audit_entry(\"data_processing\", {\n            \"data_type\": data_type,\n            \"classification\": classification.value,\n            \"purpose\": purpose,\n            \"legal_basis\": legal_basis,\n            \"processor_id\": processor_id,\n            \"timestamp\": record.timestamp.isoformat()\n        })\n    \n    def record_consent(self, subject_id: str, purpose: str, data_types: List[str],\n                      consent_method: str, informed: bool = True) -> str:\n        \"\"\"Record consent from data subject.\"\"\"\n        consent_id = hashlib.sha256(f\"{subject_id}_{purpose}_{datetime.now().timestamp()}\".encode()).hexdigest()[:16]\n        \n        consent_record = {\n            \"subject_id\": subject_id,\n            \"purpose\": purpose,\n            \"data_types\": data_types,\n            \"consent_method\": consent_method,\n            \"informed\": informed,\n            \"timestamp\": datetime.now().isoformat(),\n            \"withdrawn\": False\n        }\n        \n        self.consent_records[consent_id] = consent_record\n        \n        # Add to audit trail\n        self._add_audit_entry(\"consent_recorded\", {\n            \"consent_id\": consent_id,\n            \"subject_id\": subject_id,\n            \"purpose\": purpose,\n            \"data_types\": data_types,\n            \"timestamp\": consent_record[\"timestamp\"]\n        })\n        \n        return consent_id\n    \n    def withdraw_consent(self, consent_id: str, subject_id: str) -> bool:\n        \"\"\"Withdraw consent.\"\"\"\n        if consent_id not in self.consent_records:\n            return False\n        \n        consent_record = self.consent_records[consent_id]\n        if consent_record[\"subject_id\"] != subject_id:\n            return False\n        \n        consent_record[\"withdrawn\"] = True\n        consent_record[\"withdrawal_timestamp\"] = datetime.now().isoformat()\n        \n        # Add to audit trail\n        self._add_audit_entry(\"consent_withdrawn\", {\n            \"consent_id\": consent_id,\n            \"subject_id\": subject_id,\n            \"timestamp\": datetime.now().isoformat()\n        })\n        \n        return True\n    \n    def register_violation_callback(self, callback: Callable) -> None:\n        \"\"\"Register callback for compliance violations.\"\"\"\n        self.violation_callbacks.append(callback)\n    \n    def register_audit_callback(self, callback: Callable) -> None:\n        \"\"\"Register callback for audit events.\"\"\"\n        self.audit_callbacks.append(callback)\n    \n    def get_compliance_status(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive compliance status.\"\"\"\n        uptime = (datetime.now() - self.monitor_start_time).total_seconds()\n        \n        # Calculate violation statistics\n        recent_violations = [\n            v for v in self.violations\n            if (datetime.now() - v.timestamp).days < 30\n        ]\n        \n        violation_counts = {}\n        for violation in recent_violations:\n            framework = violation.framework.value\n            if framework not in violation_counts:\n                violation_counts[framework] = {\"critical\": 0, \"high\": 0, \"medium\": 0, \"low\": 0}\n            violation_counts[framework][violation.severity] += 1\n        \n        return {\n            \"monitoring_active\": self.monitoring_active,\n            \"uptime_seconds\": uptime,\n            \"enabled_frameworks\": [f.value for f in self.enabled_frameworks],\n            \"compliance_status\": {f.value: s.value for f, s in self.compliance_status.items()},\n            \"total_checks\": self.total_checks,\n            \"total_violations\": self.total_violations,\n            \"resolved_violations\": self.resolved_violations,\n            \"recent_violations\": violation_counts,\n            \"active_data_processing_records\": len(self.data_processing_records),\n            \"active_consent_records\": len(self.consent_records),\n            \"audit_trail_size\": len(self.audit_trail),\n            \"data_retention_schedules\": len(self.data_retention_schedule),\n            \"compliance_rules\": {f.value: len([r for r in self.compliance_rules.values() if r.framework == f]) for f in self.enabled_frameworks},\n            \"timestamp\": datetime.now().isoformat()\n        }\n    \n    def get_violations(self, framework: ComplianceFramework = None, severity: str = None,\n                      limit: int = 100) -> List[Dict[str, Any]]:\n        \"\"\"Get compliance violations.\"\"\"\n        violations = list(self.violations)\n        \n        # Filter by framework\n        if framework:\n            violations = [v for v in violations if v.framework == framework]\n        \n        # Filter by severity\n        if severity:\n            violations = [v for v in violations if v.severity == severity]\n        \n        # Sort by timestamp (most recent first)\n        violations.sort(key=lambda x: x.timestamp, reverse=True)\n        \n        # Limit results\n        violations = violations[:limit]\n        \n        # Convert to dict format\n        return [\n            {\n                \"framework\": v.framework.value,\n                \"rule_id\": v.rule_id,\n                \"severity\": v.severity,\n                \"description\": v.description,\n                \"component\": v.component,\n                \"data_involved\": v.data_involved,\n                \"timestamp\": v.timestamp.isoformat(),\n                \"resolved\": v.resolved,\n                \"remediation_actions\": v.remediation_actions,\n                \"evidence\": v.evidence\n            }\n            for v in violations\n        ]\n    \n    def get_audit_trail(self, event_type: str = None, limit: int = 100) -> List[Dict[str, Any]]:\n        \"\"\"Get audit trail entries.\"\"\"\n        entries = list(self.audit_trail)\n        \n        # Filter by event type\n        if event_type:\n            entries = [e for e in entries if e[\"event_type\"] == event_type]\n        \n        # Sort by timestamp (most recent first)\n        entries.sort(key=lambda x: x[\"timestamp\"], reverse=True)\n        \n        # Convert timestamps and return\n        return [\n            {\n                \"timestamp\": e[\"timestamp\"].isoformat(),\n                \"event_type\": e[\"event_type\"],\n                \"details\": e[\"details\"]\n            }\n            for e in entries[:limit]\n        ]"